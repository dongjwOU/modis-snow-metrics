;jiang Zhu, 1/25/2012,jiang@gina.alaska.edu
;
;This program calls subroutines to process a snow-year time-series data according to Keshav Prasad Paudel
;Keshav Prasad Paudel, Peter Andersen, Monitoring snow cover variability in an agropastoral area in the trans himalayan region of nepal using
;MODIS data with improved cloud removal methodology, remote sensing of environment 115 (2011) 1234-1246
;it includes 1. define the Da, Dmax,and Dmin, 2. process data points between Da and Dmax, and Dmax and Dmin to get the smoothed time series.
;3. get snow metrics
;smooth the one-year time-series data, and calculate the snow metrics for the one-year time-series data.
;The inputs are: 
;tmp_cover (one-snowyear-time-series-cvector), 
;tmp_fract
;tmp_quali

;outputs are:
;mid_interp (mid-year interpolated vector),
;mid_smooth (mod-year smoothed vector),
;mid_bname (mid-year smoothed vector's band names),
;vmetrics (mid-year metrics).
 
;jzhu, 5/5/2011, use the program provided by Amy to do moving smooth and calculate the crossover
 
;jzhu, 9/8/2011, ver9 processes the one-year-stacking file which includes ndvi and bq together.  

pro time_series_oneyear_dailysnow_kp,tmp_cover,tmp_fract,tmp_quali,tmp_albed,bnames,mid_cover,mid_fract,mid_bname,vmetrics

   ;time_series_oneyear_dailysnow_kp,tmp_cover,tmp_fract,tmp_quali,tmp_albed,bnames,mid_cover,mid_fract,mid_bname,vmetrics


;----1. determine if calculate the metrics of the time-series


idx = where( (tmp_cover EQ 25 or tmp_cover EQ 200 ), cnt, complement=idxcomp); cnt = number of snow-free land and snow-covered land

if cnt LE 30 then begin  ; valid number is less than 30, do not calculate metrics, metrics = 0  <1>

idx_ocean=where(tmp_cover EQ 255 or tmp_cover EQ 39,cnt_ocean)   ;cnt_ocean = number of ocen points
mid_cover=tmp_cover
mid_fract=tmp_fract
mid_bname=bnames
flg_metrics=0  ; flg_metrics=0
vmetrics(*)=0
if cnt_ocean GE 0.8*n_elements(tmp_cover) then begin  ; if number of ocean or fill points is more than 0.8*total number
flg_metrics=-1
vmetrics(*)=flg_metrics  ; flg_metrics=-1
endif

return

endif ; corresponds to if <1>


;----1.5 found the un-consisitence among cover,fract,albed,quali, do some adjustment of the un-consistence

;adjust_unconsistence, tmp_cover,tmp_fract, tmp_albed, tmp_quali, newcv


;----2. Adjacent temporal deduction of cloud points

adjacent_deduction_cloud, tmp_cover, newcv_aj



;----determine Da,Dmax,Dmin, this is called snow cycle, you may choose 0-idx_dmax-last_idx as snow cycle for test

idx_snow= where(tmp_fract GT 0 and tmp_fract LE 100, cnt_snow)

idxda=0  ; 0---first index

idxfirst=find_forward_consequtive_snow_v2(newcv_aj,tmp_fract, tmp_albed, bnames,16)

;idx_dmax=where( tmp_fract EQ  max( tmp_fract(idx_snow ) ) )  

;idxfirst=idx_dmax(0)

idxlast=find_backward_consequtive_snow_v2( newcv_aj, tmp_fract, tmp_albed, bnames,16)

;idxlast=idx_dmax( n_elements(idx_dmax)-1 )

idxdmin = n_elements(tmp_fract)-1  ; last index


;----re-classify the cover, devide the time-series into three segements: 0 point-first 100% point, first 100% point to last 100% point,and last 100% point to last point

newcv=newcv_aj  ; this is necessary

cloud_reclassify_v2, newcv_aj,tmp_fract,idxlast+1,idxdmin, 1,newcv


cloud_reclassify_v2, newcv_aj,tmp_fract, idxfirst,idxlast,1,newcv 


cloud_reclassify_v2, newcv_aj,tmp_fract, idxda,idxfirst-1,  3,newcv 


cloud_reclassify_v2, newcv_aj,tmp_fract, idxda,idxfirst-1,  2,newcv


cloud_reclassify_v2, newcv_aj,tmp_fract, idxfirst,idxlast,3,newcv


cloud_reclassify_v2, newcv_aj,tmp_fract, idxlast+1,idxdmin, 4, newcv


;------ snow_metrics

snow_metrics_calcu, tmp_cover, newcv, tmp_fract, tmp_albed, tmp_quali,bnames, newfract,vmetrics


;tmp = tmp_fract
;tmp(idx) =tmp_fract(idx)
;tmp(idxcomp)=255


;---- calls interpol_extension_1y_vector_ver9.pro to process one-year data, do one-year vector extension, then inpterpolate

;interpol_extension_dailysnow,tmp,tmp_cover,bnames,tmp_interp,flg_metrics

;---flg_metrics -1, missing data, not calculate, 0--not good data, not calculate, 1-- good data, calculate 


;----- calculate metrics-----------------------------
;---calls wls_smooth to do smooth. wls_smooth is developed based on the method 
;---that Daniel L. Swets originally developed, except including combined windows

;wls_smooth, tmp_interp,2,2,tmp_smooth

;metrics_dailysnow, tmp_smooth,tmp_interp,tmp_bq_interp,tmp_bname_interp, metrics_cal_threshold,vmetrics ;vout--smoothed vector, vorg--orginal vector, vmetrics--metrics
;metrics_dailysnow, tmp_smooth,tmp_cover,bnames,vmetrics

mid_cover=newcv
mid_fract=newfract
mid_bname=bnames

;flg_metrics=1
;metrics(9)=flg_metrics
;vmetrics = metrics

return

end
