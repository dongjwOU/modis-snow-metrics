pro get_css_indics_v4, newcv, fract,albed, quali,bname,first_idx, last_idx, css_st, css_ed, stidx, edidx

;get_css_indics2, newcv, fract, albed, quali, first_idx, last_idx, css_st, css_ed, stidx, edidx
;input newcv, first snow day index, last snow day index, resonable css first index, resonable css last index
;output first css index, last css index
;use find_forward_consequtive_snow and find_backward_consecutive_snow.pro 
;jzhu, 2012/6/8, get-css_indics_v4.pro is modified from get_css_indics_v2.pro. It identify multiple segements of css
;in the time series. save the longest css, and also report how many segements. A css segment is defined as 14 days css days.


;---initilize the first_css_idx and last_css_idx with -1

stidx  = -1
edidx  = -1

num=n_elements(newcv)

;---check if first_idx, css_st,  css_ed, last_idx are in increasing order
;if (first_idx LE css_st and css_st LE css_ed and css_ed LE last_idx ) EQ 0 then begin
;return
;endif



;--- check if there is un-breaked period between css_st and css_ed, if not, return first_css_idx=-1 and last_css_idx=-1
;idx_nosnow = where(newcv(css_st:css_ed) EQ 25,no_snow_cnt)
;if no_snow_cnt GT  then begin   ; do not get reasonable css first and last indics
;return
;endif

;--- from first_idx to num-1,look for first_css_idx, otherwise, set first_css_idx=first_idx

snow_num=css_ed-css_st + 1

snow_num=14 ; 14 consecutive snow day as a css segment

;---- define a array to hold segment sequence number and start and end indics

segno    = intarr(20)
segstidx=  intarr(20)
segedidx=  intarr(20)
seginfo={segno:segno,segstidx:segstidx,segedidx:segedidx}

;---looking for the suitable snowpoints, must be snow, fraction of snow >=50%, and albedo >=30%

;idx=where(newcv(first_idx:last_idx) EQ 200 and $
;          fract(first_idx:last_idx) GE 50  and $
;          albed(first_idx:last_idx) GE 30, cnt)

idx=where(newcv(first_idx:last_idx) EQ 200 and $
          fract(first_idx:last_idx) GE 50, cnt)


if cnt GT 0 then begin ;<1> found possible css

;assume first_idx+idx(0) to first_idx+idx( n_elements(idx)-1 ) points of newcv only have no-snow (no-snow, lake,ocean) or snow (rest of types)
;go one by one check
idx_css_ck_st=first_idx+idx(0)
idx_css_ck_ed=first_idx+idx( n_elements(idx)-1 )

idx_nosnow = where( newcv(idx_css_ck_st: idx_css_ck_ed) NE 25 or $
                    newcv(idx_css_ck_st: idx_css_ck_ed) NE 37 or $
                    newcv(idx_css_ck_st: idx_css_ck_ed) NE 39, cnt_nosnow)


;---check no-snow point to determine how to divide the css segements

k=0  ; star fromt the first no-snow idx

m=1  ; segment sequnce no

found_hd=0; find_header_flag, 0= not found, 1=found

found_ed=0;

while k LT cnt_nosnow do begin  ;<2>

if found_hr EQ 0 then begin ;<10> , try to find header

;check m segment header
  if m EQ 1 then begin ; <3> find the first segment heder
  
  segheader=idx_css_ck_st
  
  found_hd=1
  goto, lb_found
  
  endif else begin ; <3> try to find the segment m header
  
  
  ;check if k+1 exists
  
  if k+1 GT cnt_nosnow then begin ; the last segment 
  
  found_hd=1
  
  segheader=idx_css_ck_st+idx_nosnow(k)+1
  goto,lb_found
  
  
  endif 
  
  
if idx_nosnow(k)+j LT idx_nosnow(k+j) then begin ;<11> found header
  
     segheader=idx_css_ck_st+idx_nosnow(k)+1
     
     found_hd=1
     
     goto, lb_found
            
   endif else begin  ;<11>
      
   k=k+1 

  endelse ;<11>
  
  
  endelse  ;<3>
 

endif else begin ;<10>, found header, try to find the ender  


 ;check if k+1 exists
  
 if k+1 GT cnt_nosnow then begin ;<20>
 
 found_ed=1
 segender=idx_css_ck_st+idx_nosnow(k)-1
 
 goto,lb_found
 
 endif ;<20>
 
;---- compare k with k+1 
if idx_nosnow(k)+1 LT idx_nosnow(k+1) then begin ;<4>, found segemnt m ender
  
    found_ed=1
    segender=idx_css_ck_st+idx_nosnow(k)-1
    goto,lb_found
        
endif ;<4>

;----check if k+2 exists

 if k+1 GT cnt_nosnow then begin
 
 found_ed=1
 segender=idx_css_ck_st+idx_nosnow(k)-1
 
 goto,lb_found
 
 endif 

;----compare k with k+1 and k+2  

if idx_nosnow(k+1)+1 LT idx_no_snow(k+2) then begin ; <6> scape k and k+1  
      
     k=k+2

  
endif else begin ;<6> found segment m ender
 
    found_ed=1
    segender=idx_css_ck+idx_nosnow(k)-1     

endelse ;< 6>

    
endelse ; <10>



lb_found:

if found_hd EQ 1 and found_ed EQ 1 then begin; <12> 

segno=m
segidxst[m]=segheader
segidxed[m]=segender

;prepare to process the next segment

found_hr=0
found_ed=0     
m=m+1
    
endif ;<12>   

 
endwhile ; <2> next round   

  
  
  
  
;---- check stidx and edidx  

if stidx EQ -1 or edidx EQ -1 or stidx GT edidx then begin ;<13>


if stidx GT edidx then begin; <14>

print, 'check why'

endif ;<14>

stidx=-1
edidx=-1

;print,'check why can not locate css

endif ;<13>


endif ;<1>

return

end
 